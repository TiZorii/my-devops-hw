// Django/Jenkinsfile

pipeline {
    agent {
        kubernetes {
            yaml """
                apiVersion: v1
                kind: Pod
                spec:
                  containers:
                  - name: docker
                    image: docker:dind
                    securityContext:
                      privileged: true
                    volumeMounts:
                    - name: docker-sock
                      mountPath: /var/run/docker.sock
                  - name: kubectl
                    image: bitnami/kubectl:latest
                    command:
                    - cat
                    tty: true
                  - name: aws-cli
                    image: amazon/aws-cli:latest
                    command:
                    - cat
                    tty: true
                  volumes:
                  - name: docker-sock
                    hostPath:
                      path: /var/run/docker.sock
            """
        }
    }
    
    environment {
        // ECR Configuration
        ECR_REGISTRY = '178795995292.dkr.ecr.us-east-1.amazonaws.com'
        ECR_REPOSITORY = '178795995292.dkr.ecr.us-east-1.amazonaws.com/devops-final-dev-django-app'
        AWS_DEFAULT_REGION = 'us-east-1'
        
        // Image tags
        IMAGE_TAG = "${BUILD_NUMBER}"
        LATEST_TAG = "latest"
        
        // Kubernetes
        KUBE_NAMESPACE = "default"
        APP_NAME = "django-app"
        
        // Build info
        GIT_COMMIT_SHORT = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
        BUILD_DATE = sh(script: "date -u +'%Y-%m-%dT%H:%M:%SZ'", returnStdout: true).trim()
    }
    
    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 30, unit: 'MINUTES')
        timestamps()
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT_SHORT = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
                }
            }
        }
        
        stage('Build Info') {
            steps {
                script {
                    echo "====== Build Information ======"
                    echo "Build Number: ${BUILD_NUMBER}"
                    echo "Git Commit: ${GIT_COMMIT_SHORT}"
                    echo "Build Date: ${BUILD_DATE}"
                    echo "ECR Repository: ${ECR_REPOSITORY}"
                    echo "Image Tag: ${IMAGE_TAG}"
                    echo "================================"
                }
            }
        }
        
        stage('Lint & Test') {
            steps {
                container('docker') {
                    script {
                        echo "Running tests..."
                        // Build test image
                        sh """
                            cd Django
                            docker build -t ${APP_NAME}-test:${BUILD_NUMBER} --target builder .
                            docker run --rm ${APP_NAME}-test:${BUILD_NUMBER} python -m pytest --version || echo 'Tests skipped - pytest not configured'
                        """
                    }
                }
            }
        }
        
        stage('Build Docker Image') {
            steps {
                container('docker') {
                    script {
                        echo "Building Docker image..."
                        sh """
                            cd Django
                            docker build \
                                -t ${ECR_REPOSITORY}:${IMAGE_TAG} \
                                -t ${ECR_REPOSITORY}:${LATEST_TAG} \
                                --build-arg BUILD_NUMBER=${BUILD_NUMBER} \
                                --build-arg GIT_COMMIT=${GIT_COMMIT_SHORT} \
                                --build-arg BUILD_DATE='${BUILD_DATE}' \
                                .
                        """
                        
                        // Verify image
                        sh "docker images | grep ${APP_NAME}"
                    }
                }
            }
        }
        
        stage('Security Scan') {
            steps {
                container('docker') {
                    script {
                        echo "Running security scan..."
                        // Basic image scan
                        sh """
                            docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                                aquasec/trivy:latest image --exit-code 0 --severity HIGH,CRITICAL \
                                ${ECR_REPOSITORY}:${IMAGE_TAG} || echo 'Security scan completed with warnings'
                        """
                    }
                }
            }
        }
        
        stage('Push to ECR') {
            steps {
                container('aws-cli') {
                    script {
                        echo "Logging in to ECR..."
                        sh """
                            aws ecr get-login-password --region ${AWS_DEFAULT_REGION} | \
                            docker login --username AWS --password-stdin ${ECR_REGISTRY}
                        """
                    }
                }
                
                container('docker') {
                    script {
                        echo "Pushing images to ECR..."
                        sh """
                            docker push ${ECR_REPOSITORY}:${IMAGE_TAG}
                            docker push ${ECR_REPOSITORY}:${LATEST_TAG}
                        """
                        
                        echo "Successfully pushed images:"
                        echo "- ${ECR_REPOSITORY}:${IMAGE_TAG}"
                        echo "- ${ECR_REPOSITORY}:${LATEST_TAG}"
                    }
                }
            }
        }
        
        stage('Update Kubernetes Manifests') {
            when {
                branch 'main'
            }
            steps {
                container('kubectl') {
                    script {
                        echo "Updating Kubernetes deployment..."
                        
                        // Check if deployment exists
                        def deploymentExists = sh(
                            script: "kubectl get deployment ${APP_NAME} -n ${KUBE_NAMESPACE}",
                            returnStatus: true
                        ) == 0
                        
                        if (deploymentExists) {
                            // Update existing deployment
                            sh """
                                kubectl set image deployment/${APP_NAME} \
                                    ${APP_NAME}=${ECR_REPOSITORY}:${IMAGE_TAG} \
                                    -n ${KUBE_NAMESPACE}
                                
                                kubectl annotate deployment/${APP_NAME} \
                                    deployment.kubernetes.io/revision-history="Build ${BUILD_NUMBER}, Commit ${GIT_COMMIT_SHORT}" \
                                    -n ${KUBE_NAMESPACE} --overwrite
                            """
                            
                            // Wait for rollout
                            sh """
                                kubectl rollout status deployment/${APP_NAME} \
                                    -n ${KUBE_NAMESPACE} --timeout=300s
                            """
                        } else {
                            echo "Deployment ${APP_NAME} not found. Skipping update."
                            echo "Please deploy via ArgoCD first."
                        }
                    }
                }
            }
        }
        
        stage('Deploy to Development') {
            when {
                branch 'main'
            }
            steps {
                container('kubectl') {
                    script {
                        echo "Verifying deployment..."
                        
                        // Get deployment status
                        sh """
                            kubectl get deployment ${APP_NAME} -n ${KUBE_NAMESPACE} -o wide
                            kubectl get pods -l app=${APP_NAME} -n ${KUBE_NAMESPACE}
                        """
                        
                        // Run health check
                        sh """
                            kubectl wait --for=condition=available --timeout=300s \
                                deployment/${APP_NAME} -n ${KUBE_NAMESPACE} || echo 'Deployment check completed with warnings'
                        """
                    }
                }
            }
        }
        
        stage('Integration Tests') {
            when {
                branch 'main'
            }
            steps {
                container('kubectl') {
                    script {
                        echo "Running integration tests..."
                        
                        // Get service endpoint
                        def serviceIP = sh(
                            script: "kubectl get svc ${APP_NAME} -n ${KUBE_NAMESPACE} -o jsonpath='{.spec.clusterIP}'",
                            returnStdout: true
                        ).trim()
                        
                        if (serviceIP) {
                            sh """
                                kubectl run test-pod --rm -i --restart=Never --image=curlimages/curl:latest \
                                    -- curl -f http://${serviceIP}:8000/health/ || echo 'Health check completed'
                            """
                        }
                    }
                }
            }
        }
    }
    
    post {
        always {
            script {
                echo "====== Build Summary ======"
                echo "Status: ${currentBuild.result ?: 'SUCCESS'}"
                echo "Duration: ${currentBuild.durationString}"
                echo "Image: ${ECR_REPOSITORY}:${IMAGE_TAG}"
                echo "=========================="
            }
            
            // Cleanup
            container('docker') {
                sh """
                    docker system prune -f || echo 'Docker cleanup completed'
                """
            }
        }
        
        success {
            echo "Pipeline completed successfully! ðŸŽ‰"
        }
        
        failure {
            echo "Pipeline failed! Please check the logs."
        }
        
        unstable {
            echo "Pipeline completed with warnings."
        }
    }
}